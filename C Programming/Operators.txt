Operator precendance:

1) %, * , / 
2) + , -
3) =

when same precendance opertaor comes in eqaution then we follow associativity (i.e left to right for all 1 and 2 step) but for 3rd step i.e = (right to left)

Example1: a = 4 * 5 + 30/2 -1;
so we first evaluate 4*5 then 30/2 then add then -.
as left associativity.

And when talking about multiple assignment operator in single expression then in that case it flow from right to left associativity but left must be the variable.

Modulo operator(%) -> both the operands of % operator must be int type else error.
sign of result of % operator will be same as of 1st operand.
-ve % +ve = -ve , -ve % -ve = -ve , +ve % +ve = +ve , +ve % -ve = +ve.


Example: int a;
a = 12.6 / 3 % 4 + 2
a= 4.2 % 4 + 2 (left associativity)
a = error
bcz both the operands of % operator should be int.

Operator precendance:
0) Uniary operator top precendance like +, -, ! which only one operand
1) % * /
2) + -
3) < , <=, >, >=
4) !=, ==
5) &&
6) ||
7) =


1. Arithmetic Operators
Used for mathematical operations.
Operator	Meaning
+	Addition
-	Subtraction
*	Multiplication
/	Division
%	Modulus (remainder)
Example:
a + b
a % b


ðŸ”¥ 2. Relational Operators
Used for comparison (true=1, false=0).
Operator	Meaning
<	Less than
>	Greater than
<=	Less than or equal
>=	Greater than or equal
==	Equal to
!=	Not equal to
Example:
a >= b
a == b


ðŸ”¥ 3. Logical Operators
Used for conditions.
Operator	Meaning
&&	Logical AND
!	Logical NOT
Example:
(a > 5 && b < 10)


ðŸ”¥ 4. Bitwise Operators
Used to manipulate bits (very important for low-level programming).
Operator	Meaning
&	Bitwise AND
^	Bitwise XOR
~	Bitwise NOT
<<	Left Shift
>>	Right Shift


ðŸ”¥ 5. Assignment Operators
Used to assign values.
Operator	Meaning
=	Simple assignment
+=	Add and assign
-=	Subtract and assign
*=	Multiply and assign
/=	Divide and assign
%=	Modulus and assign
Example:
x += 5; // same as x = x + 5;


ðŸ”¥ 6. Increment & Decrement Operators
Operator	Meaning
++	Increment
--	Decrement
Two types:
Pre-increment: ++x
Post-increment: x++


ðŸ”¥ 7. Conditional (Ternary) Operator
Only operator with 3 operands.
(condition) ? value_if_true : value_if_false
Example:
x = (a > b) ? a : b;


ðŸ”¥ 8. Comma Operator
Evaluates multiple expressions, returns last value.
int x = (1, 2, 3);  // x = 3


ðŸ”¥ 9. Sizeof Operator
Gives size of a variable or datatype in bytes.
sizeof(int);  


ðŸ”¥ 10. Pointer Operators
Operator	Meaning
&	Address of variable
*	Value at address (dereference)
int *p;
p = &x;  // address


ðŸ”¥ 11. Member Access Operators
Used with structures.
A) Direct access:
.

B) Access through pointer:
->


ðŸ”¥ 12. Typecasting Operators
Converts one type to another.
(float)a


Note: Agr &&(and) operator ka phele operand 0, false hai too compiler dusre operand to evaluate nahi karta . isko hi short-circuit evaluation of and operator bolte hai.


Example1: int i =4;
int j;
j = ++i + ++i + i++;

Solution: As per C standard,it is written that you are not allowed to modify the value of a variable more than once between two sequence points.
Meaning: Compiler may give any result
Output depends on compiler, optimization, system architecture, evaluation order
Different compilers produce different output
Sometimes even the same compiler will show different results at different optimization levels
So this code is invalid for reliable execution.

Sequence Points: Sequence point is a place where all previous side effects are guaranteed to be completed.

Examples:
End of full expression ;
Operators: &&, ||, ? :, comma ,
Function call (after all arguments)
But in -> ++i + ++i + i++ , there is no sequence point between the 3 modifications. 

Example1:
int a , b, c ,d;
a = 2, b=3, c=1;
d = ++a || ++b && c++;
printf("%d %d %d %d",a,b,c,d);

Sol: Here ++a becomes 3 which means a true value ,so according to short-circuit rule of || , it will not execute b and c , so d becomes 1.And final output will be 3 3 1 1


Number System:
1) decimal number system : 10 symbol -> 0,1,2,----9
2) Binary number system: 2 symbol -> 0, 1
3) Octal number system : 8 symbol -> 0,1,2,3,4,5,6,7
4) Hexadecimal number system: 16 symbol (0-9, A,B,C,D,E,F)

Decimal to octal conversion -> divide the number by 8 till the quotient becomes zero. for (70) it will be (106) in octal. we need to read it in reverse order of division.
Octal to Decimal conversion -> it is similar to binary to decimal , the only difference is here we multiple it with 8 instead of 2. So fo 106 in octal will be 70 in decimal.


Decimal to Hexadecimal conversion-> divide the number till the quotient becomes zero from 16. for 70 in Decimal will be 46 in Hexadecimal.

Example1: Let say there is number 172 in decimal to convert it in hexadecimal we divide it by 16 till the quootient becomes 0. so at start the remainder we get is 12 but in Hexadecimal we can write 2 digit number like this , so we have A to F , A-10, B-11, C-12 and so on till F.
So the remainder at start become C then again on dividing the remainder we get is 10 which is A.
Therefore, 172 in hexadecimal will be (AC)

And for reverse i.e Hexadecimal to Decimal , we just multiply it with 16 and for AC kind of thing , convert them to their respective number i.e 10 and 12.


Bitwise Operator:
1) Bitwise OR(|)
2) Bitwise AND(&)
3) Bitwise XOR(^)
4) Bitwise not(~) -> Uniary operator and rest all others are binary
5) Left shift( <<)
6) Right shift (>>)

for XOR case -> if both the bits are different then 1 , if both bits are same then output 0.

â€œSir, left shift multiplies the number by 2 for every shift.
So a << b is equal to a multiplied by 2 power b.â€
-> left shift=> a<<b => a * 2^b means shift binary of a to the left side b number of times.
10<<1 = 10 * 2^ 1 = 20
10<<2 = 10 * 2^2 = 40
In binary format -> 10 = 1010 , then 1010 << 1 = 10100 i.e 20
1010 << 2 = 101000 i.e 40

Now for doing right shift, we do 10 >> 2 => 10 / 2^2


GATE me basically compiler 2 byte ka hota hai matlab 16 bits, so humne binary representation bhi 16 bits me karna hoga , let say 5 << 3 hai too hume 5 ka binary version 16 bits me represent karna hoga 0000000000000101. 


2â€™s Complement kya hota hai?
Ye ek binary method hai jisse computers negative numbers ko store karte hain.

Iski need kyu padti hai? (Most important)
Pehle 2 tarike the:
Sign-Magnitude
1â€™s Complement

Dono me problems:
âŒ Problem 1: Zero ke 2 version
+0 aur -0
Bahut confusing.
âŒ Problem 2: Addition aur subtraction mushkil
Hardware ko extra logic lagana padta tha.

2â€™s Complement ka fayda kya?

2â€™s complement aate hi:
âœ” Zero ek hi ho gaya
âœ” Addition/subtraction simple ho gaya (normal binary math)
âœ” CPU fast kaam karta hai
âœ” Hardware simple ho gaya

Jab bhi negative integer binary me store hota hai â†’ 2â€™s complement use hota hai.

Example1: int x = -5;
Step 1: +5 ko binary me likho => 00000101
Step 2: Bits flip karo (1â€™s complement) => 11111010
Step 3: +1 add karo
11111010  
+      1  
---------
11111011

Ye 11111011 hi -5 ka 2â€™s complement binary hai.

okay and agr -2 ka nikalna hoo too  -2 => 0010 then flip it 1101
then add +1 too right most , 1+1 = 0 and carrry will be one , so it will gives 1110


Floor() -> it returns nearest smaller integer of input.
Example-> Floor(6.1) => 6 , Floor(6.9) => 6 , Floor(-3.2) = -4

Ceil -> it returns nearest greater integer of input.
Example -> Ceil(6.1) => 7, Ceil(6.9) => 7, Ceil(-3.2) => -3